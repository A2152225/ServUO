#region References
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using Server.Commands.Generic;
using Server.Targeting;
#endregion

namespace Server.Commands
{
    public class MakeScriptCommand
    {
        public static void Initialize()
        {
            CommandSystem.Register("MakeScript", AccessLevel.Administrator, MakeScript_OnCommand);
            
            // Register with the area command system
            TargetCommands.Register(new MakeScriptBaseCommand());
        }

        [Usage("MakeScript")]
        [Description("Creates a .txt file with the properties of the targeted item/mobile that can be compiled as a .cs script.")]
        private static void MakeScript_OnCommand(CommandEventArgs e)
        {
            e.Mobile.Target = new MakeScriptTarget();
            e.Mobile.SendMessage("Target an item or mobile to generate a script.");
        }

        private class MakeScriptTarget : Target
        {
            public MakeScriptTarget()
                : base(15, false, TargetFlags.None)
            {
            }

            protected override void OnTarget(Mobile from, object targeted)
            {
                if (targeted == null)
                {
                    from.SendMessage("Invalid target.");
                    return;
                }

                if (!(targeted is Item) && !(targeted is Mobile))
                {
                    from.SendMessage("You can only target items or mobiles.");
                    return;
                }

                try
                {
                    string script = MakeScriptCommand.GenerateScript(targeted);
                    string fileName = MakeScriptCommand.SaveScript(script, targeted);
                    
                    from.SendMessage("Script generated: {0}", fileName);
                    
                    CommandLogging.WriteLine(
                        from,
                        "{0} {1} generated script for {2}",
                        from.AccessLevel,
                        CommandLogging.Format(from),
                        CommandLogging.Format(targeted));
                }
                catch (Exception ex)
                {
                    from.SendMessage("Error generating script: {0}", ex.Message);
                    Console.WriteLine(ex);
                }
            }
        }

        public static string SaveScript(string script, object obj)
        {
            string timestamp = DateTime.Now.ToString("yyyy-MM-dd_HH-mm-ss");
            string typeName = obj.GetType().Name;
            string fileName = string.Format("MakeScript-{0}-{1}.txt", typeName, timestamp);
            string filePath = Path.Combine(Core.BaseDirectory, fileName);
            
            File.WriteAllText(filePath, script);
            
            return fileName;
        }

        public static string GenerateScript(object obj)
        {
            Type type = obj.GetType();
            StringBuilder sb = new StringBuilder();

            // Add header comment
            sb.AppendLine("// Generated by [MakeScript command");
            sb.AppendLine("// Date: " + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"));
            sb.AppendLine("// Original Type: " + type.FullName);
            sb.AppendLine();

            // Add using statements
            sb.AppendLine("using System;");
            sb.AppendLine("using Server;");
            
            if (obj is Item)
            {
                sb.AppendLine("using Server.Items;");
            }
            else if (obj is Mobile)
            {
                sb.AppendLine("using Server.Mobiles;");
            }
            
            sb.AppendLine();

            // Determine namespace
            string namespaceName = type.Namespace ?? "Server.Items";
            sb.AppendLine("namespace " + namespaceName);
            sb.AppendLine("{");

            // Start class definition
            string className = "Generated" + type.Name;
            sb.AppendLine("    public class " + className + " : " + type.Name);
            sb.AppendLine("    {");
            
            // Add customizable name variable
            sb.AppendLine("        // Change this name to customize the item name");
            sb.AppendLine("        private static readonly string ItemName = \"" + GetObjectName(obj) + "\";");
            sb.AppendLine();

            // Add constructor
            sb.AppendLine("        [Constructable]");
            sb.AppendLine("        public " + className + "()");
            
            // Get constructor parameters from base class
            ConstructorInfo[] ctors = type.GetConstructors(BindingFlags.Public | BindingFlags.Instance);
            ConstructorInfo defaultCtor = ctors.FirstOrDefault(c => c.GetParameters().Length == 0);
            
            if (defaultCtor != null)
            {
                sb.AppendLine("            : base()");
            }
            else
            {
                // Try to find a simple constructor
                ConstructorInfo simpleCtor = ctors.OrderBy(c => c.GetParameters().Length).FirstOrDefault();
                if (simpleCtor != null && simpleCtor.GetParameters().Length > 0)
                {
                    var parameters = simpleCtor.GetParameters();
                    var paramList = string.Join(", ", parameters.Select(p => GetDefaultValue(p.ParameterType)));
                    sb.AppendLine("            : base(" + paramList + ")");
                }
            }
            
            sb.AppendLine("        {");
            
            // Set properties
            var properties = GetWritableProperties(type, obj);
            foreach (var prop in properties)
            {
                try
                {
                    object value = prop.GetValue(obj, null);
                    
                    // Special handling for Name property
                    if (prop.Name == "Name")
                    {
                        sb.AppendLine("            " + prop.Name + " = ItemName;");
                    }
                    else
                    {
                        string valueStr = FormatValue(value, prop.PropertyType);
                        
                        // Special handling for Hue - show as hex
                        if (prop.Name == "Hue" && value is int)
                        {
                            int hueValue = (int)value;
                            if (hueValue != 0)
                                valueStr = "0x" + hueValue.ToString("X");
                        }
                        
                        sb.AppendLine("            " + prop.Name + " = " + valueStr + ";");
                    }
                }
                catch
                {
                    // Skip properties that can't be read
                }
            }
            
            sb.AppendLine("        }");
            sb.AppendLine();

            // Add serialization constructor
            sb.AppendLine("        public " + className + "(Serial serial)");
            sb.AppendLine("            : base(serial)");
            sb.AppendLine("        {");
            sb.AppendLine("        }");
            sb.AppendLine();

            // Add Serialize method
            sb.AppendLine("        public override void Serialize(GenericWriter writer)");
            sb.AppendLine("        {");
            sb.AppendLine("            base.Serialize(writer);");
            sb.AppendLine("            writer.Write((int)0); // version");
            sb.AppendLine("        }");
            sb.AppendLine();

            // Add Deserialize method
            sb.AppendLine("        public override void Deserialize(GenericReader reader)");
            sb.AppendLine("        {");
            sb.AppendLine("            base.Deserialize(reader);");
            sb.AppendLine("            int version = reader.ReadInt();");
            sb.AppendLine("        }");

            // Close class and namespace
            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private static string GetObjectName(object obj)
        {
            if (obj is Item item && !string.IsNullOrEmpty(item.Name))
                return item.Name;
            if (obj is Mobile mobile && !string.IsNullOrEmpty(mobile.Name))
                return mobile.Name;
            
            return obj.GetType().Name;
        }

        private static List<PropertyInfo> GetWritableProperties(Type type, object obj)
        {
            var properties = new List<PropertyInfo>();
            var allProps = type.GetProperties(BindingFlags.Public | BindingFlags.Instance);

            foreach (var prop in allProps)
            {
                if (!prop.CanWrite || !prop.CanRead)
                    continue;

                // Check for CommandPropertyAttribute
                var cpa = Properties.GetCPA(prop);
                if (cpa != null && cpa.ReadOnly)
                    continue;

                // Skip certain properties
                if (IsSkippedProperty(prop.Name))
                    continue;

                // Skip properties defined in base Item/Mobile that are typically set by the system
                if (IsSystemProperty(prop.Name))
                    continue;

                properties.Add(prop);
            }

            return properties;
        }

        private static bool IsSkippedProperty(string name)
        {
            string[] skipped = new string[]
            {
                "Serial", "Parent", "Map", "Location", "X", "Y", "Z",
                "Items", "Backpack", "Followers", "FollowersMax",
                "Region", "NetState", "Account", "AccessLevel",
                "LastMoved", "Created", "Deleted", "RootParent",
                "RootParentEntity", "PropertyList", "Context",
                "Effects", "Aggressed", "Aggressors", "Gump",
                "Skills", "Stabled", "StatMods"
            };

            return skipped.Contains(name);
        }

        private static bool IsSystemProperty(string name)
        {
            // Properties that are typically managed by the system
            string[] systemProps = new string[]
            {
                "TotalItems", "TotalWeight", "TotalGold",
                "AllFollowers", "Mounted"
            };

            return systemProps.Contains(name);
        }

        private static string FormatValue(object value, Type type)
        {
            if (value == null)
                return "null";

            if (type == typeof(string))
            {
                // Proper C# string literal escaping
                string str = value.ToString();
                str = str.Replace("\\", "\\\\"); // Backslash first
                str = str.Replace("\"", "\\\""); // Quote
                str = str.Replace("\r", "\\r");  // Carriage return
                str = str.Replace("\n", "\\n");  // Newline
                str = str.Replace("\t", "\\t");  // Tab
                return "\"" + str + "\"";
            }

            if (type == typeof(bool))
                return value.ToString().ToLower();

            if (type.IsEnum)
                return type.Name + "." + value.ToString();

            if (type == typeof(TimeSpan))
            {
                TimeSpan ts = (TimeSpan)value;
                return string.Format("TimeSpan.FromSeconds({0})", ts.TotalSeconds);
            }

            if (type == typeof(DateTime))
            {
                return "DateTime.UtcNow";
            }

            if (type.Name == "Point3D")
            {
                // Extract X, Y, Z properties directly for robust formatting
                try
                {
                    var xProp = type.GetProperty("X");
                    var yProp = type.GetProperty("Y");
                    var zProp = type.GetProperty("Z");
                    
                    if (xProp != null && yProp != null && zProp != null)
                    {
                        int x = (int)xProp.GetValue(value, null);
                        int y = (int)yProp.GetValue(value, null);
                        int z = (int)zProp.GetValue(value, null);
                        return string.Format("new Point3D({0}, {1}, {2})", x, y, z);
                    }
                }
                catch
                {
                    // Fallback to ToString if reflection fails
                }
                return string.Format("new Point3D({0})", value.ToString().Replace(",", ", "));
            }

            if (type.IsPrimitive || type == typeof(decimal))
                return value.ToString();

            // For complex types, try to serialize
            return "default(" + type.Name + ")";
        }

        private static string GetDefaultValue(Type type)
        {
            if (type == typeof(string))
                return "\"\"";
            if (type == typeof(int) || type == typeof(short) || type == typeof(byte))
                return "0";
            if (type == typeof(bool))
                return "false";
            if (type.IsEnum)
                return "(" + type.Name + ")0";
            
            return "default(" + type.Name + ")";
        }
    }

    // Command for use with [Area and [Where
    public class MakeScriptBaseCommand : BaseCommand
    {
        public MakeScriptBaseCommand()
        {
            AccessLevel = AccessLevel.Administrator;
            Supports = CommandSupport.AllItems | CommandSupport.AllMobiles | CommandSupport.Area;
            Commands = new[] { "MakeScript" };
            ObjectTypes = ObjectTypes.All;
            Usage = "MakeScript";
            Description = "Generates scripts for all targeted items/mobiles.";
            ListOptimized = true;
        }

        public override void ExecuteList(CommandEventArgs e, ArrayList list)
        {
            if (list.Count == 0)
            {
                AddResponse("No objects found.");
                return;
            }

            try
            {
                // For small lists, generate full scripts. For large lists, generate summaries
                bool generateFullScripts = list.Count <= 10;
                
                StringBuilder combinedScript = new StringBuilder();
                combinedScript.AppendLine("// Generated by [MakeScript command with area/where");
                combinedScript.AppendLine("// Date: " + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"));
                combinedScript.AppendLine("// Total objects: " + list.Count);
                combinedScript.AppendLine("// Mode: " + (generateFullScripts ? "Full Scripts" : "Property Summary"));
                combinedScript.AppendLine();

                foreach (object obj in list)
                {
                    if (obj is Item || obj is Mobile)
                    {
                        combinedScript.AppendLine("// ==========================================");
                        combinedScript.AppendLine("// Object: " + obj.GetType().Name);
                        combinedScript.AppendLine("// ==========================================");
                        combinedScript.AppendLine();
                        
                        if (generateFullScripts)
                        {
                            // Generate full script for each object
                            string script = MakeScriptCommand.GenerateScript(obj);
                            combinedScript.AppendLine(script);
                        }
                        else
                        {
                            // Generate property summary only
                            string script = GenerateIndividualScript(obj);
                            combinedScript.AppendLine(script);
                        }
                        combinedScript.AppendLine();
                    }
                }

                string timestamp = DateTime.Now.ToString("yyyy-MM-dd_HH-mm-ss");
                string fileName = string.Format("MakeScript-Area-{0}.txt", timestamp);
                string filePath = Path.Combine(Core.BaseDirectory, fileName);
                
                File.WriteAllText(filePath, combinedScript.ToString());
                
                AddResponse("Generated scripts for {0} objects: {1}", list.Count, fileName);
                
                CommandLogging.WriteLine(
                    e.Mobile,
                    "{0} {1} generated area scripts for {2} objects",
                    e.Mobile.AccessLevel,
                    CommandLogging.Format(e.Mobile),
                    list.Count);
            }
            catch (Exception ex)
            {
                AddResponse("Error: " + ex.Message);
                Console.WriteLine(ex);
            }
        }

        public static string GenerateIndividualScript(object obj)
        {
            Type type = obj.GetType();
            StringBuilder sb = new StringBuilder();

            sb.AppendLine("/*");
            sb.AppendLine(" * Type: " + type.FullName);
            
            if (obj is Item item)
            {
                sb.AppendLine(" * Serial: 0x" + item.Serial.Value.ToString("X"));
                if (!string.IsNullOrEmpty(item.Name))
                    sb.AppendLine(" * Name: " + item.Name);
            }
            else if (obj is Mobile mobile)
            {
                sb.AppendLine(" * Serial: 0x" + mobile.Serial.Value.ToString("X"));
                if (!string.IsNullOrEmpty(mobile.Name))
                    sb.AppendLine(" * Name: " + mobile.Name);
            }
            
            sb.AppendLine(" * Properties:");
            
            var properties = GetWritablePropertiesWithValues(type, obj);
            foreach (var kvp in properties)
            {
                sb.AppendLine(" *   " + kvp.Key + " = " + kvp.Value);
            }
            
            sb.AppendLine(" */");

            return sb.ToString();
        }

        public static Dictionary<string, string> GetWritablePropertiesWithValues(Type type, object obj)
        {
            var result = new Dictionary<string, string>();
            var allProps = type.GetProperties(BindingFlags.Public | BindingFlags.Instance);

            foreach (var prop in allProps)
            {
                if (!prop.CanRead)
                    continue;

                // Skip certain properties
                string[] skipped = new string[]
                {
                    "Serial", "Parent", "Map", "Items", "Backpack",
                    "Region", "NetState", "Account", "Deleted"
                };

                if (skipped.Contains(prop.Name))
                    continue;

                try
                {
                    object value = prop.GetValue(obj, null);
                    string valueStr = FormatValueForComment(value);
                    result[prop.Name] = valueStr;
                }
                catch
                {
                    // Skip properties that can't be read
                }
            }

            return result;
        }

        public static string FormatValueForComment(object value)
        {
            if (value == null)
                return "null";

            if (value is string)
                return "\"" + value.ToString() + "\"";

            return value.ToString();
        }
    }
}
